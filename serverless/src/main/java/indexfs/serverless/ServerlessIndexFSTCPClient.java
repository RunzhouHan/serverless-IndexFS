package main.java.indexfs.serverless;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.OutputStreamWriter;
import java.net.ConnectException;
import java.net.Socket;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.apache.commons.logging.LogFactory;

/**
 * TCP server listening to Json payload generated by workload from IndexFS client.
 */
public class ServerlessIndexFSTCPClient extends Thread {
    private static final org.apache.commons.logging.Log LOG = LogFactory.getLog(ServerlessIndexFSTCPClient.class);
    
    /**
     * This is the maximum amount of time a call to connect() will block. Calls to connect() occur when
     * establishing a connection to a new client.
     */
    private static final int CONNECTION_TIMEOUT = 60000;
    
    
    /**
     * The deployment number of the local serverless name node instance.
     */
    private final int serverless_server_id;
    
    
    /**
     * Client Socket.
     */    
    private Socket clientSocket;
    
    
    /**
     * Serverless IndexFS I/O driver.
     */
    private ServerlessIndexFSDriver driver;
    
    /**
     * Number of Serverless IndexFS clients.
     */
    // public static int clients = 0;
    
    private int client_id;
   
    
    private ServerlessIndexFSInputParser parser;
    
    
	/**
	 * The concurrency lock to protect write operations.
	 * In our experiments we only have a single root folder, 
	 * so we simply lock the Mknode method when a client is using it. 
	 */
    ReadWriteLock lock = new ReentrantReadWriteLock();    
	
    // private ServerlessIndexFSTCPClient[] tcpClients;
    
    // private String client_ip;
    
    // private int client_port;
    
    // private int deployement_id;
    
       
    /**
     * Constructor
     * @param config
     * @param driver
     */
    public ServerlessIndexFSTCPClient(ServerlessIndexFSConfig config, ServerlessIndexFSDriver driver_,
    		int client_id) {
    	this.serverless_server_id = config.GetSvrID();
    	this.driver = driver_;
    	this.parser = new ServerlessIndexFSInputParser();
    	this.client_id = client_id;
    	// this.client_ip = config.GetClientIP();
    	// this.tcpClients = new ServerlessIndexFSTCPClient[config.GetClientNum()];
    	// this.deployement_id = config.GetSvrID();
    }
    
    /**
     * Connect to IndexFS client (TCP server) with given IP & port
     * @param client_ip
     * @param client_port
     * @throws IOException
     */
    public void connect(String client_ip, int client_port) throws IOException {
    	// Wait for the server to start
		long startTime = System.nanoTime();
		
		long timeout = CONNECTION_TIMEOUT;
    	while(timeout > 0) {
    		try {
    			clientSocket = new Socket(client_ip, client_port);
    			// System.out.println("Connected to " + client_ip + ":" + client_port);
    			break;
    		} catch (ConnectException e) {
    			// System.out.println("Connect failed, waiting and trying again");
    			// e.printStackTrace(System.out);
    			try {
    				Thread.sleep(1000);// 1 second
    				timeout = timeout - 1000;
		        } catch(InterruptedException ie){
    		        ie.printStackTrace();
    		    }
    			if (timeout == 0)
    				 System.out.println("TCP connection timeout");
    		}
    	}
		long endTime = System.nanoTime();
		long duration = (endTime - startTime)/1000000;

        String ready = "ServerlessIndexFSTCPClient.connect: IndexFS TCP client has been established on port " 
    			+ client_ip + ":" + client_port + " in: "  + duration + "ms";
        // System.out.println(ready);
        try {
			PrintWriter outToClient = new PrintWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
	        outToClient.print(ready);
            outToClient.flush();
		} catch (IOException e) {
			if (clientSocket != null) {
                clientSocket.close();
                System.out.println(String.format("ServerlessIndexFSTCPClient.connect: Could not connect to: %s on port: %d", 
                		client_ip, client_port));
            }
		}
    }

    /**
     * Check if connection is established
     * @return 
     */
    public boolean checkConnection() {
    	try {
        	DataInputStream in = new DataInputStream(clientSocket.getInputStream());
        	return true;
    	} catch (Exception e){
    		return false;
    	}
    }
    
    
    /**
     * Receive workload requests from client as TCP payload, and process the request. 
     */
    public void run() {
    	long THREAD_ID = 0;
        try {
        	THREAD_ID = Thread.currentThread().getId();
            System.out.println(
                "ServerlessIndexFSTCPClient.run(): Thread " + THREAD_ID
                + " is receiving client payload");
        }
        catch (Exception e) {
            System.out.println("ServerlessIndexFSTCPClient.run(): Failed to get thread ID");
        }
    	DataInputStream in = null;
		try {
			in = new DataInputStream(clientSocket.getInputStream());
		} catch (IOException e1) {
			System.out.println("ServerlessIndexFSTCPClient.run(): Thread " + THREAD_ID
					+ " getInputStream() failed");
			// e1.printStackTrace();
		}
    	PrintWriter strwriter = null;
		try {
			strwriter = new PrintWriter(clientSocket.getOutputStream());
		} catch (IOException e1) {
			System.out.println("ServerlessIndexFSTCPClient.run(): Thread " + THREAD_ID
					+ " getOutputStream() failed");
			// e1.printStackTrace();
		}
    	InputStreamReader reader = new InputStreamReader(in);
    	BufferedReader b_reader = new BufferedReader(reader);
    	ServerlessIndexFSParsedArgs parsed_args = new ServerlessIndexFSParsedArgs();
    	
    	
        try {
        	String inputLine;
        	long duration_parse, duration_one, duration_proceed;
        	duration_parse = duration_one = duration_proceed= 0; 
        	long startTime = System.nanoTime();
        	long tmp1, tmp2;
    		
    		int i = 0;
            while ((inputLine = b_reader.readLine()) != null) {
            	if (inputLine.length() == 1) {
            		System.out.println("KILL SIGNAL: " + inputLine);
            		break;
            	}
            	tmp1 = System.nanoTime();
            	
            	parsed_args = parser.inputStringParse(inputLine);
            	
            	duration_parse += System.nanoTime()-tmp1;
            	tmp2 = System.nanoTime();
            	
            	long op_type = -1;
            	
            	if (parsed_args != null) {
            		
            		if (!parsed_args.op_type.equals("Getattr")) {
            			// write lock upon Mknod & Mkdir. We can do this because we don't have sub-folders in the root folder.
            			lock.writeLock().lock(); 
        				try {
        					op_type = driver.proceedClientRequest(parsed_args);
        				} finally {
        			        lock.writeLock().unlock();
        			    }	
            		}
            		else {
            			// read lock upon Getattr. 
//        				lock.writeLock().lock(); 
//        				try {
        					op_type = driver.proceedClientRequest(parsed_args);
//        				} finally {
//        			        lock.writeLock().unlock();
//        			    }	            			
            		}
            	}
            		
    			if(op_type != 0) {
    				// Read operation. Send result back to IndexFS client
    				 strwriter.write(String.valueOf(op_type));
    				 System.out.println("read inode: " + String.valueOf(op_type));
    				 strwriter.flush();
    			}
    			duration_one = System.nanoTime() - tmp2;
    			duration_proceed += duration_one;
    			if ((duration_one/1000000) > 5) {
    				System.out.println("Outlier opertaion: " + parsed_args.op_type + " " 
    						+ parsed_args.path + " - " + duration_one/1000000 + "ms");
    			} 
    			i++;
			}
			long endTime = System.nanoTime();
			long duration = (endTime - startTime)/1000000;
			System.out.println("Client I/O request finished");
			System.out.println("readline parse duration(ms): " + duration_parse/1000000);
			System.out.println("readline proceed duration(ms): " + duration_proceed/1000000);
			System.out.println("readline duration(ms): " + duration);
			
			strwriter.close();
			disconnect();
			
        } catch (IOException e) {
            e.printStackTrace(); 
            disconnect();
        }
    }
    
    
    /**
     * Disconnect from TCP server
     */
    public void disconnect() {
    	System.out.println("ServerlessIndexFSTCPClient.disconnect");
        try {
	        clientSocket.close();
	        System.out.println("disconnected client " + client_id);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("failed to disconnect TCP communication between serverless IndexFS and client");
		}  

    }
}
